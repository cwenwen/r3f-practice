/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */const S={LEFT:1,RIGHT:2,MIDDLE:4},s=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,SCREEN_PAN:4,OFFSET:8,DOLLY:16,ZOOM:32,TOUCH_ROTATE:64,TOUCH_TRUCK:128,TOUCH_SCREEN_PAN:256,TOUCH_OFFSET:512,TOUCH_DOLLY:1024,TOUCH_ZOOM:2048,TOUCH_DOLLY_TRUCK:4096,TOUCH_DOLLY_SCREEN_PAN:8192,TOUCH_DOLLY_OFFSET:16384,TOUCH_DOLLY_ROTATE:32768,TOUCH_ZOOM_TRUCK:65536,TOUCH_ZOOM_OFFSET:131072,TOUCH_ZOOM_SCREEN_PAN:262144,TOUCH_ZOOM_ROTATE:524288}),k={NONE:0,IN:1,OUT:-1};function I(O){return O.isPerspectiveCamera}function N(O){return O.isOrthographicCamera}const Z=Math.PI*2,ct=Math.PI/2,Et=1e-5,K=Math.PI/180;function F(O,t,e){return Math.max(t,Math.min(e,O))}function v(O,t=Et){return Math.abs(O)<t}function L(O,t,e=Et){return v(O-t,e)}function _t(O,t){return Math.round(O/t)*t}function X(O){return isFinite(O)?O:O<0?-Number.MAX_VALUE:Number.MAX_VALUE}function Q(O){return Math.abs(O)<Number.MAX_VALUE?O:O*(1/0)}function W(O,t,e,i,r=1/0,n){i=Math.max(1e-4,i);const a=2/i,h=a*n,_=1/(1+h+.48*h*h+.235*h*h*h);let p=O-t;const x=t,E=r*i;p=F(p,-E,E),t=O-p;const D=(e.value+a*p)*n;e.value=(e.value-a*D)*_;let u=t+(p+D)*_;return x-O>0==u>x&&(u=x,e.value=(u-x)/n),u}function dt(O,t,e,i,r=1/0,n,a){i=Math.max(1e-4,i);const h=2/i,_=h*n,p=1/(1+_+.48*_*_+.235*_*_*_);let x=t.x,E=t.y,D=t.z,u=O.x-x,A=O.y-E,y=O.z-D;const P=x,o=E,l=D,c=r*i,m=c*c,T=u*u+A*A+y*y;if(T>m){const et=Math.sqrt(T);u=u/et*c,A=A/et*c,y=y/et*c}x=O.x-u,E=O.y-A,D=O.z-y;const g=(e.x+h*u)*n,U=(e.y+h*A)*n,R=(e.z+h*y)*n;e.x=(e.x-h*g)*p,e.y=(e.y-h*U)*p,e.z=(e.z-h*R)*p,a.x=x+(u+g)*p,a.y=E+(A+U)*p,a.z=D+(y+R)*p;const b=P-O.x,j=o-O.y,gt=l-O.z,Tt=a.x-P,yt=a.y-o,Ct=a.z-l;return b*Tt+j*yt+gt*Ct>0&&(a.x=P,a.y=o,a.z=l,e.x=(a.x-P)/n,e.y=(a.y-o)/n,e.z=(a.z-l)/n),a}function st(O,t){t.set(0,0),O.forEach(e=>{t.x+=e.clientX,t.y+=e.clientY}),t.x/=O.length,t.y/=O.length}function it(O,t){return N(O)?(console.warn(`${t} is not supported in OrthographicCamera`),!0):!1}class Ut{constructor(){this._listeners={}}addEventListener(t,e){const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){const r=this._listeners[t];if(r!==void 0){const n=r.indexOf(e);n!==-1&&r.splice(n,1)}}removeAllEventListeners(t){if(!t){this._listeners={};return}Array.isArray(this._listeners[t])&&(this._listeners[t].length=0)}dispatchEvent(t){const i=this._listeners[t.type];if(i!==void 0){t.target=this;const r=i.slice(0);for(let n=0,a=r.length;n<a;n++)r[n].call(this,t)}}}var ot;const Dt="2.10.0",J=1/8,Lt=/Mac/.test((ot=globalThis==null?void 0:globalThis.navigator)===null||ot===void 0?void 0:ot.platform);let d,mt,$,nt,z,f,C,V,q,M,H,Y,pt,ut,w,G,B,ft,rt,Ot,at,ht,tt;class lt extends Ut{static install(t){d=t.THREE,mt=Object.freeze(new d.Vector3(0,0,0)),$=Object.freeze(new d.Vector3(0,1,0)),nt=Object.freeze(new d.Vector3(0,0,1)),z=new d.Vector2,f=new d.Vector3,C=new d.Vector3,V=new d.Vector3,q=new d.Vector3,M=new d.Vector3,H=new d.Vector3,Y=new d.Vector3,pt=new d.Vector3,ut=new d.Vector3,w=new d.Spherical,G=new d.Spherical,B=new d.Box3,ft=new d.Box3,rt=new d.Sphere,Ot=new d.Quaternion,at=new d.Quaternion,ht=new d.Matrix4,tt=new d.Raycaster}static get ACTION(){return s}constructor(t,e){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=s.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=k.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new d.Vector3,this._focalOffsetVelocity=new d.Vector3,this._zoomVelocity={value:0},this._truckInternal=(o,l,c,m)=>{let T,g;if(I(this._camera)){const U=f.copy(this._camera.position).sub(this._target),R=this._camera.getEffectiveFOV()*K,b=U.length()*Math.tan(R*.5);T=this.truckSpeed*o*b/this._elementRect.height,g=this.truckSpeed*l*b/this._elementRect.height}else if(N(this._camera)){const U=this._camera;T=this.truckSpeed*o*(U.right-U.left)/U.zoom/this._elementRect.width,g=this.truckSpeed*l*(U.top-U.bottom)/U.zoom/this._elementRect.height}else return;m?(c?this.setFocalOffset(this._focalOffsetEnd.x+T,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(T,0,!0),this.forward(-g,!0)):c?this.setFocalOffset(this._focalOffsetEnd.x+T,this._focalOffsetEnd.y+g,this._focalOffsetEnd.z,!0):this.truck(T,g,!0)},this._rotateInternal=(o,l)=>{const c=Z*this.azimuthRotateSpeed*o/this._elementRect.height,m=Z*this.polarRotateSpeed*l/this._elementRect.height;this.rotate(c,m,!0)},this._dollyInternal=(o,l,c)=>{const m=Math.pow(.95,-o*this.dollySpeed),T=this._sphericalEnd.radius,g=this._sphericalEnd.radius*m,U=F(g,this.minDistance,this.maxDistance),R=U-g;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(g,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(R,!0),this._dollyToNoClamp(U,!0)):this._dollyToNoClamp(U,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?g:U)-T,this._dollyControlCoord.set(l,c)),this._lastDollyDirection=Math.sign(-o)},this._zoomInternal=(o,l,c)=>{const m=Math.pow(.95,o*this.dollySpeed),T=this._zoom,g=this._zoom*m;this.zoomTo(g,!0),this.dollyToCursor&&(this._changedZoom+=g-T,this._dollyControlCoord.set(l,c))},typeof d>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=t,this._yAxisUpSpace=new d.Quaternion().setFromUnitVectors(this._camera.up,$),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=s.NONE,this._target=new d.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new d.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new d.Spherical().setFromVector3(f.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new d.Vector3,new d.Vector3,new d.Vector3,new d.Vector3],this._updateNearPlaneCorners(),this._boundary=new d.Box3(new d.Vector3(-1/0,-1/0,-1/0),new d.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new d.Vector2,this.mouseButtons={left:s.ROTATE,middle:s.DOLLY,right:s.TRUCK,wheel:I(this._camera)?s.DOLLY:N(this._camera)?s.ZOOM:s.NONE},this.touches={one:s.TOUCH_ROTATE,two:I(this._camera)?s.TOUCH_DOLLY_TRUCK:N(this._camera)?s.TOUCH_ZOOM_TRUCK:s.NONE,three:s.TOUCH_TRUCK};const i=new d.Vector2,r=new d.Vector2,n=new d.Vector2,a=o=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const m=this._domElement.getBoundingClientRect(),T=o.clientX/m.width,g=o.clientY/m.height;if(T<this._interactiveArea.left||T>this._interactiveArea.right||g<this._interactiveArea.top||g>this._interactiveArea.bottom)return}const l=o.pointerType!=="mouse"?null:(o.buttons&S.LEFT)===S.LEFT?S.LEFT:(o.buttons&S.MIDDLE)===S.MIDDLE?S.MIDDLE:(o.buttons&S.RIGHT)===S.RIGHT?S.RIGHT:null;if(l!==null){const m=this._findPointerByMouseButton(l);m&&this._disposePointer(m)}if((o.buttons&S.LEFT)===S.LEFT&&this._lockedPointer)return;const c={pointerId:o.pointerId,clientX:o.clientX,clientY:o.clientY,deltaX:0,deltaY:0,mouseButton:l};this._activePointers.push(c),this._domElement.ownerDocument.removeEventListener("pointermove",h,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",_),this._domElement.ownerDocument.addEventListener("pointermove",h,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",_),this._isDragging=!0,D(o)},h=o=>{o.cancelable&&o.preventDefault();const l=o.pointerId,c=this._lockedPointer||this._findPointerById(l);if(c){if(c.clientX=o.clientX,c.clientY=o.clientY,c.deltaX=o.movementX,c.deltaY=o.movementY,this._state=0,o.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(o.buttons&S.LEFT)===S.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(o.buttons&S.MIDDLE)===S.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(o.buttons&S.RIGHT)===S.RIGHT&&(this._state=this._state|this.mouseButtons.right);u()}},_=o=>{const l=this._findPointerById(o.pointerId);if(!(l&&l===this._lockedPointer)){if(l&&this._disposePointer(l),o.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=s.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=s.NONE;A()}};let p=-1;const x=o=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===s.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const g=this._domElement.getBoundingClientRect(),U=o.clientX/g.width,R=o.clientY/g.height;if(U<this._interactiveArea.left||U>this._interactiveArea.right||R<this._interactiveArea.top||R>this._interactiveArea.bottom)return}if(o.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===s.ROTATE||this.mouseButtons.wheel===s.TRUCK){const g=performance.now();p-g<1e3&&this._getClientRect(this._elementRect),p=g}const l=Lt?-1:-3,c=o.deltaMode===1?o.deltaY/l:o.deltaY/(l*10),m=this.dollyToCursor?(o.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,T=this.dollyToCursor?(o.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case s.ROTATE:{this._rotateInternal(o.deltaX,o.deltaY),this._isUserControllingRotate=!0;break}case s.TRUCK:{this._truckInternal(o.deltaX,o.deltaY,!1,!1),this._isUserControllingTruck=!0;break}case s.SCREEN_PAN:{this._truckInternal(o.deltaX,o.deltaY,!1,!0),this._isUserControllingTruck=!0;break}case s.OFFSET:{this._truckInternal(o.deltaX,o.deltaY,!0,!1),this._isUserControllingOffset=!0;break}case s.DOLLY:{this._dollyInternal(-c,m,T),this._isUserControllingDolly=!0;break}case s.ZOOM:{this._zoomInternal(-c,m,T),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},E=o=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===lt.ACTION.NONE){const l=o instanceof PointerEvent?o.pointerId:0,c=this._findPointerById(l);c&&this._disposePointer(c),this._domElement.ownerDocument.removeEventListener("pointermove",h,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",_);return}o.preventDefault()}},D=o=>{if(!this._enabled)return;if(st(this._activePointers,z),this._getClientRect(this._elementRect),i.copy(z),r.copy(z),this._activePointers.length>=2){const c=z.x-this._activePointers[1].clientX,m=z.y-this._activePointers[1].clientY,T=Math.sqrt(c*c+m*m);n.set(0,T);const g=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,U=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;r.set(g,U)}if(this._state=0,!o)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in o&&o.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(o.buttons&S.LEFT)===S.LEFT&&(this._state=this._state|this.mouseButtons.left),(o.buttons&S.MIDDLE)===S.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(o.buttons&S.RIGHT)===S.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&s.ROTATE)===s.ROTATE||(this._state&s.TOUCH_ROTATE)===s.TOUCH_ROTATE||(this._state&s.TOUCH_DOLLY_ROTATE)===s.TOUCH_DOLLY_ROTATE||(this._state&s.TOUCH_ZOOM_ROTATE)===s.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&s.TRUCK)===s.TRUCK||(this._state&s.SCREEN_PAN)===s.SCREEN_PAN||(this._state&s.TOUCH_TRUCK)===s.TOUCH_TRUCK||(this._state&s.TOUCH_SCREEN_PAN)===s.TOUCH_SCREEN_PAN||(this._state&s.TOUCH_DOLLY_TRUCK)===s.TOUCH_DOLLY_TRUCK||(this._state&s.TOUCH_DOLLY_SCREEN_PAN)===s.TOUCH_DOLLY_SCREEN_PAN||(this._state&s.TOUCH_ZOOM_TRUCK)===s.TOUCH_ZOOM_TRUCK||(this._state&s.TOUCH_ZOOM_SCREEN_PAN)===s.TOUCH_DOLLY_SCREEN_PAN)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&s.DOLLY)===s.DOLLY||(this._state&s.TOUCH_DOLLY)===s.TOUCH_DOLLY||(this._state&s.TOUCH_DOLLY_TRUCK)===s.TOUCH_DOLLY_TRUCK||(this._state&s.TOUCH_DOLLY_SCREEN_PAN)===s.TOUCH_DOLLY_SCREEN_PAN||(this._state&s.TOUCH_DOLLY_OFFSET)===s.TOUCH_DOLLY_OFFSET||(this._state&s.TOUCH_DOLLY_ROTATE)===s.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&s.ZOOM)===s.ZOOM||(this._state&s.TOUCH_ZOOM)===s.TOUCH_ZOOM||(this._state&s.TOUCH_ZOOM_TRUCK)===s.TOUCH_ZOOM_TRUCK||(this._state&s.TOUCH_ZOOM_SCREEN_PAN)===s.TOUCH_ZOOM_SCREEN_PAN||(this._state&s.TOUCH_ZOOM_OFFSET)===s.TOUCH_ZOOM_OFFSET||(this._state&s.TOUCH_ZOOM_ROTATE)===s.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&s.OFFSET)===s.OFFSET||(this._state&s.TOUCH_OFFSET)===s.TOUCH_OFFSET||(this._state&s.TOUCH_DOLLY_OFFSET)===s.TOUCH_DOLLY_OFFSET||(this._state&s.TOUCH_ZOOM_OFFSET)===s.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},u=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,st(this._activePointers,z);const l=this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,c=l?-l.deltaX:r.x-z.x,m=l?-l.deltaY:r.y-z.y;if(r.copy(z),((this._state&s.ROTATE)===s.ROTATE||(this._state&s.TOUCH_ROTATE)===s.TOUCH_ROTATE||(this._state&s.TOUCH_DOLLY_ROTATE)===s.TOUCH_DOLLY_ROTATE||(this._state&s.TOUCH_ZOOM_ROTATE)===s.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(c,m),this._isUserControllingRotate=!0),(this._state&s.DOLLY)===s.DOLLY||(this._state&s.ZOOM)===s.ZOOM){const T=this.dollyToCursor?(i.x-this._elementRect.x)/this._elementRect.width*2-1:0,g=this.dollyToCursor?(i.y-this._elementRect.y)/this._elementRect.height*-2+1:0,U=this.dollyDragInverted?-1:1;(this._state&s.DOLLY)===s.DOLLY?(this._dollyInternal(U*m*J,T,g),this._isUserControllingDolly=!0):(this._zoomInternal(U*m*J,T,g),this._isUserControllingZoom=!0)}if((this._state&s.TOUCH_DOLLY)===s.TOUCH_DOLLY||(this._state&s.TOUCH_ZOOM)===s.TOUCH_ZOOM||(this._state&s.TOUCH_DOLLY_TRUCK)===s.TOUCH_DOLLY_TRUCK||(this._state&s.TOUCH_ZOOM_TRUCK)===s.TOUCH_ZOOM_TRUCK||(this._state&s.TOUCH_DOLLY_SCREEN_PAN)===s.TOUCH_DOLLY_SCREEN_PAN||(this._state&s.TOUCH_ZOOM_SCREEN_PAN)===s.TOUCH_ZOOM_SCREEN_PAN||(this._state&s.TOUCH_DOLLY_OFFSET)===s.TOUCH_DOLLY_OFFSET||(this._state&s.TOUCH_ZOOM_OFFSET)===s.TOUCH_ZOOM_OFFSET||(this._state&s.TOUCH_DOLLY_ROTATE)===s.TOUCH_DOLLY_ROTATE||(this._state&s.TOUCH_ZOOM_ROTATE)===s.TOUCH_ZOOM_ROTATE){const T=z.x-this._activePointers[1].clientX,g=z.y-this._activePointers[1].clientY,U=Math.sqrt(T*T+g*g),R=n.y-U;n.set(0,U);const b=this.dollyToCursor?(r.x-this._elementRect.x)/this._elementRect.width*2-1:0,j=this.dollyToCursor?(r.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&s.TOUCH_DOLLY)===s.TOUCH_DOLLY||(this._state&s.TOUCH_DOLLY_ROTATE)===s.TOUCH_DOLLY_ROTATE||(this._state&s.TOUCH_DOLLY_TRUCK)===s.TOUCH_DOLLY_TRUCK||(this._state&s.TOUCH_DOLLY_SCREEN_PAN)===s.TOUCH_DOLLY_SCREEN_PAN||(this._state&s.TOUCH_DOLLY_OFFSET)===s.TOUCH_DOLLY_OFFSET?(this._dollyInternal(R*J,b,j),this._isUserControllingDolly=!0):(this._zoomInternal(R*J,b,j),this._isUserControllingZoom=!0)}((this._state&s.TRUCK)===s.TRUCK||(this._state&s.TOUCH_TRUCK)===s.TOUCH_TRUCK||(this._state&s.TOUCH_DOLLY_TRUCK)===s.TOUCH_DOLLY_TRUCK||(this._state&s.TOUCH_ZOOM_TRUCK)===s.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(c,m,!1,!1),this._isUserControllingTruck=!0),((this._state&s.SCREEN_PAN)===s.SCREEN_PAN||(this._state&s.TOUCH_SCREEN_PAN)===s.TOUCH_SCREEN_PAN||(this._state&s.TOUCH_DOLLY_SCREEN_PAN)===s.TOUCH_DOLLY_SCREEN_PAN||(this._state&s.TOUCH_ZOOM_SCREEN_PAN)===s.TOUCH_ZOOM_SCREEN_PAN)&&(this._truckInternal(c,m,!1,!0),this._isUserControllingTruck=!0),((this._state&s.OFFSET)===s.OFFSET||(this._state&s.TOUCH_OFFSET)===s.TOUCH_OFFSET||(this._state&s.TOUCH_DOLLY_OFFSET)===s.TOUCH_DOLLY_OFFSET||(this._state&s.TOUCH_ZOOM_OFFSET)===s.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(c,m,!0,!1),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},A=()=>{st(this._activePointers,z),r.copy(z),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",h,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",_),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",h,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",_),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",y),this._domElement.ownerDocument.addEventListener("pointerlockerror",P),this._domElement.ownerDocument.addEventListener("pointermove",h,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",_),D())},this.unlockPointer=()=>{var o,l,c;this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),(o=this._domElement)===null||o===void 0||o.ownerDocument.exitPointerLock(),(l=this._domElement)===null||l===void 0||l.ownerDocument.removeEventListener("pointerlockchange",y),(c=this._domElement)===null||c===void 0||c.ownerDocument.removeEventListener("pointerlockerror",P),this.cancel()};const y=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},P=()=>{this.unlockPointer()};this._addAllEventListeners=o=>{this._domElement=o,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",a),this._domElement.addEventListener("pointercancel",_),this._domElement.addEventListener("wheel",x,{passive:!1}),this._domElement.addEventListener("contextmenu",E)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",a),this._domElement.removeEventListener("pointercancel",_),this._domElement.removeEventListener("wheel",x,{passive:!1}),this._domElement.removeEventListener("contextmenu",E),this._domElement.ownerDocument.removeEventListener("pointermove",h,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",_),this._domElement.ownerDocument.removeEventListener("pointerlockchange",y),this._domElement.ownerDocument.removeEventListener("pointerlockerror",P))},this.cancel=()=>{this._state!==s.NONE&&(this._state=s.NONE,this._activePointers.length=0,A())},e&&this.connect(e),this.update(0)}get camera(){return this._camera}set camera(t){this._camera=t,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._domElement&&(t?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(t){this._spherical.radius===t&&this._sphericalEnd.radius===t||(this._spherical.radius=t,this._sphericalEnd.radius=t,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(t){this._spherical.theta===t&&this._sphericalEnd.theta===t||(this._spherical.theta=t,this._sphericalEnd.theta=t,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(t){this._spherical.phi===t&&this._sphericalEnd.phi===t||(this._spherical.phi=t,this._sphericalEnd.phi=t,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(t){this._boundaryEnclosesCamera=t,this._needsUpdate=!0}set interactiveArea(t){this._interactiveArea.width=F(t.width,0,1),this._interactiveArea.height=F(t.height,0,1),this._interactiveArea.x=F(t.x,0,1-this._interactiveArea.width),this._interactiveArea.y=F(t.y,0,1-this._interactiveArea.height)}addEventListener(t,e){super.addEventListener(t,e)}removeEventListener(t,e){super.removeEventListener(t,e)}rotate(t,e,i=!1){return this.rotateTo(this._sphericalEnd.theta+t,this._sphericalEnd.phi+e,i)}rotateAzimuthTo(t,e=!1){return this.rotateTo(t,this._sphericalEnd.phi,e)}rotatePolarTo(t,e=!1){return this.rotateTo(this._sphericalEnd.theta,t,e)}rotateTo(t,e,i=!1){this._isUserControllingRotate=!1;const r=F(t,this.minAzimuthAngle,this.maxAzimuthAngle),n=F(e,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=r,this._sphericalEnd.phi=n,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,i||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const a=!i||L(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&L(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(a)}dolly(t,e=!1){return this.dollyTo(this._sphericalEnd.radius-t,e)}dollyTo(t,e=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=k.NONE,this._changedDolly=0,this._dollyToNoClamp(F(t,this.minDistance,this.maxDistance),e)}_dollyToNoClamp(t,e=!1){const i=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const a=this._collisionTest(),h=L(a,this._spherical.radius);if(!(i>t)&&h)return Promise.resolve();this._sphericalEnd.radius=Math.min(t,a)}else this._sphericalEnd.radius=t;this._needsUpdate=!0,e||(this._spherical.radius=this._sphericalEnd.radius);const n=!e||L(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(n)}dollyInFixed(t,e=!1){this._targetEnd.add(this._getCameraDirection(q).multiplyScalar(t)),e||this._target.copy(this._targetEnd);const i=!e||L(this._target.x,this._targetEnd.x,this.restThreshold)&&L(this._target.y,this._targetEnd.y,this.restThreshold)&&L(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(i)}zoom(t,e=!1){return this.zoomTo(this._zoomEnd+t,e)}zoomTo(t,e=!1){this._isUserControllingZoom=!1,this._zoomEnd=F(t,this.minZoom,this.maxZoom),this._needsUpdate=!0,e||(this._zoom=this._zoomEnd);const i=!e||L(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(i)}pan(t,e,i=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(t,e,i)}truck(t,e,i=!1){this._camera.updateMatrix(),M.setFromMatrixColumn(this._camera.matrix,0),H.setFromMatrixColumn(this._camera.matrix,1),M.multiplyScalar(t),H.multiplyScalar(-e);const r=f.copy(M).add(H),n=C.copy(this._targetEnd).add(r);return this.moveTo(n.x,n.y,n.z,i)}forward(t,e=!1){f.setFromMatrixColumn(this._camera.matrix,0),f.crossVectors(this._camera.up,f),f.multiplyScalar(t);const i=C.copy(this._targetEnd).add(f);return this.moveTo(i.x,i.y,i.z,e)}elevate(t,e=!1){return f.copy(this._camera.up).multiplyScalar(t),this.moveTo(this._targetEnd.x+f.x,this._targetEnd.y+f.y,this._targetEnd.z+f.z,e)}moveTo(t,e,i,r=!1){this._isUserControllingTruck=!1;const n=f.set(t,e,i).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,n,this.boundaryFriction),this._needsUpdate=!0,r||this._target.copy(this._targetEnd);const a=!r||L(this._target.x,this._targetEnd.x,this.restThreshold)&&L(this._target.y,this._targetEnd.y,this.restThreshold)&&L(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(a)}lookInDirectionOf(t,e,i,r=!1){const h=f.set(t,e,i).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);return this.setPosition(h.x,h.y,h.z,r)}fitToBox(t,e,{cover:i=!1,paddingLeft:r=0,paddingRight:n=0,paddingBottom:a=0,paddingTop:h=0}={}){const _=[],p=t.isBox3?B.copy(t):B.setFromObject(t);p.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const x=_t(this._sphericalEnd.theta,ct),E=_t(this._sphericalEnd.phi,ct);_.push(this.rotateTo(x,E,e));const D=f.setFromSpherical(this._sphericalEnd).normalize(),u=Ot.setFromUnitVectors(D,nt),A=L(Math.abs(D.y),1);A&&u.multiply(at.setFromAxisAngle($,x)),u.multiply(this._yAxisUpSpaceInverse);const y=ft.makeEmpty();C.copy(p.min).applyQuaternion(u),y.expandByPoint(C),C.copy(p.min).setX(p.max.x).applyQuaternion(u),y.expandByPoint(C),C.copy(p.min).setY(p.max.y).applyQuaternion(u),y.expandByPoint(C),C.copy(p.max).setZ(p.min.z).applyQuaternion(u),y.expandByPoint(C),C.copy(p.min).setZ(p.max.z).applyQuaternion(u),y.expandByPoint(C),C.copy(p.max).setY(p.min.y).applyQuaternion(u),y.expandByPoint(C),C.copy(p.max).setX(p.min.x).applyQuaternion(u),y.expandByPoint(C),C.copy(p.max).applyQuaternion(u),y.expandByPoint(C),y.min.x-=r,y.min.y-=a,y.max.x+=n,y.max.y+=h,u.setFromUnitVectors(nt,D),A&&u.premultiply(at.invert()),u.premultiply(this._yAxisUpSpace);const P=y.getSize(f),o=y.getCenter(C).applyQuaternion(u);if(I(this._camera)){const l=this.getDistanceToFitBox(P.x,P.y,P.z,i);_.push(this.moveTo(o.x,o.y,o.z,e)),_.push(this.dollyTo(l,e)),_.push(this.setFocalOffset(0,0,0,e))}else if(N(this._camera)){const l=this._camera,c=l.right-l.left,m=l.top-l.bottom,T=i?Math.max(c/P.x,m/P.y):Math.min(c/P.x,m/P.y);_.push(this.moveTo(o.x,o.y,o.z,e)),_.push(this.zoomTo(T,e)),_.push(this.setFocalOffset(0,0,0,e))}return Promise.all(_)}fitToSphere(t,e){const i=[],n="isObject3D"in t?lt.createBoundingSphere(t,rt):rt.copy(t);if(i.push(this.moveTo(n.center.x,n.center.y,n.center.z,e)),I(this._camera)){const a=this.getDistanceToFitSphere(n.radius);i.push(this.dollyTo(a,e))}else if(N(this._camera)){const a=this._camera.right-this._camera.left,h=this._camera.top-this._camera.bottom,_=2*n.radius,p=Math.min(a/_,h/_);i.push(this.zoomTo(p,e))}return i.push(this.setFocalOffset(0,0,0,e)),Promise.all(i)}setLookAt(t,e,i,r,n,a,h=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=k.NONE,this._changedDolly=0;const _=C.set(r,n,a),p=f.set(t,e,i);this._targetEnd.copy(_),this._sphericalEnd.setFromVector3(p.sub(_).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,h||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const x=!h||L(this._target.x,this._targetEnd.x,this.restThreshold)&&L(this._target.y,this._targetEnd.y,this.restThreshold)&&L(this._target.z,this._targetEnd.z,this.restThreshold)&&L(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&L(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&L(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(x)}lerpLookAt(t,e,i,r,n,a,h,_,p,x,E,D,u,A=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=k.NONE,this._changedDolly=0;const y=f.set(r,n,a),P=C.set(t,e,i);w.setFromVector3(P.sub(y).applyQuaternion(this._yAxisUpSpace));const o=V.set(x,E,D),l=C.set(h,_,p);G.setFromVector3(l.sub(o).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(y.lerp(o,u));const c=G.theta-w.theta,m=G.phi-w.phi,T=G.radius-w.radius;this._sphericalEnd.set(w.radius+T*u,w.phi+m*u,w.theta+c*u),this.normalizeRotations(),this._needsUpdate=!0,A||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const g=!A||L(this._target.x,this._targetEnd.x,this.restThreshold)&&L(this._target.y,this._targetEnd.y,this.restThreshold)&&L(this._target.z,this._targetEnd.z,this.restThreshold)&&L(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&L(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&L(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(g)}setPosition(t,e,i,r=!1){return this.setLookAt(t,e,i,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,r)}setTarget(t,e,i,r=!1){const n=this.getPosition(f),a=this.setLookAt(n.x,n.y,n.z,t,e,i,r);return this._sphericalEnd.phi=F(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),a}setFocalOffset(t,e,i,r=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(t,e,i),this._needsUpdate=!0,r||this._focalOffset.copy(this._focalOffsetEnd);const n=!r||L(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&L(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&L(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(n)}setOrbitPoint(t,e,i){this._camera.updateMatrixWorld(),M.setFromMatrixColumn(this._camera.matrixWorldInverse,0),H.setFromMatrixColumn(this._camera.matrixWorldInverse,1),Y.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const r=f.set(t,e,i),n=r.distanceTo(this._camera.position),a=r.sub(this._camera.position);M.multiplyScalar(a.x),H.multiplyScalar(a.y),Y.multiplyScalar(a.z),f.copy(M).add(H).add(Y),f.z=f.z+n,this.dollyTo(n,!1),this.setFocalOffset(-f.x,f.y,-f.z,!1),this.moveTo(t,e,i,!1)}setBoundary(t){if(!t){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(t),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(t,e,i,r){if(t===null){this._viewport=null;return}this._viewport=this._viewport||new d.Vector4,typeof t=="number"?this._viewport.set(t,e,i,r):this._viewport.copy(t)}getDistanceToFitBox(t,e,i,r=!1){if(it(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const n=t/e,a=this._camera.getEffectiveFOV()*K,h=this._camera.aspect;return((r?n>h:n<h)?e:t/h)*.5/Math.tan(a*.5)+i*.5}getDistanceToFitSphere(t){if(it(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const e=this._camera.getEffectiveFOV()*K,i=Math.atan(Math.tan(e*.5)*this._camera.aspect)*2,r=1<this._camera.aspect?e:i;return t/Math.sin(r*.5)}getTarget(t,e=!0){return(t&&t.isVector3?t:new d.Vector3).copy(e?this._targetEnd:this._target)}getPosition(t,e=!0){return(t&&t.isVector3?t:new d.Vector3).setFromSpherical(e?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e?this._targetEnd:this._target)}getSpherical(t,e=!0){return(t||new d.Spherical).copy(e?this._sphericalEnd:this._spherical)}getFocalOffset(t,e=!0){return(t&&t.isVector3?t:new d.Vector3).copy(e?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%Z,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=Z),this._spherical.theta+=Z*Math.round((this._sphericalEnd.theta-this._spherical.theta)/Z)}stop(){this._focalOffset.copy(this._focalOffsetEnd),this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd),this._zoom=this._zoomEnd}reset(t=!1){if(!L(this._camera.up.x,this._cameraUp0.x)||!L(this._camera.up.y,this._cameraUp0.y)||!L(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const i=this.getPosition(f);this.updateCameraUp(),this.setPosition(i.x,i.y,i.z)}const e=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,t),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,t),this.zoomTo(this._zoom0,t)];return Promise.all(e)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,$),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const t=f.subVectors(this._target,this._camera.position).normalize(),e=C.crossVectors(t,this._camera.up);this._camera.up.crossVectors(e,t).normalize(),this._camera.updateMatrixWorld();const i=this.getPosition(f);this.updateCameraUp(),this.setPosition(i.x,i.y,i.z)}update(t){const e=this._sphericalEnd.theta-this._spherical.theta,i=this._sphericalEnd.phi-this._spherical.phi,r=this._sphericalEnd.radius-this._spherical.radius,n=pt.subVectors(this._targetEnd,this._target),a=ut.subVectors(this._focalOffsetEnd,this._focalOffset),h=this._zoomEnd-this._zoom;if(v(e))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const E=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=W(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,E,1/0,t),this._needsUpdate=!0}if(v(i))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const E=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=W(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,E,1/0,t),this._needsUpdate=!0}if(v(r))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const E=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=W(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,E,this.maxSpeed,t),this._needsUpdate=!0}if(v(n.x)&&v(n.y)&&v(n.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const E=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;dt(this._target,this._targetEnd,this._targetVelocity,E,this.maxSpeed,t,this._target),this._needsUpdate=!0}if(v(a.x)&&v(a.y)&&v(a.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const E=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;dt(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,E,this.maxSpeed,t,this._focalOffset),this._needsUpdate=!0}if(v(h))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const E=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=W(this._zoom,this._zoomEnd,this._zoomVelocity,E,1/0,t)}if(this.dollyToCursor){if(I(this._camera)&&this._changedDolly!==0){const E=this._spherical.radius-this._lastDistance,D=this._camera,u=this._getCameraDirection(q),A=f.copy(u).cross(D.up).normalize();A.lengthSq()===0&&(A.x=1);const y=C.crossVectors(A,u),P=this._sphericalEnd.radius*Math.tan(D.getEffectiveFOV()*K*.5),l=(this._sphericalEnd.radius-E-this._sphericalEnd.radius)/this._sphericalEnd.radius,c=V.copy(this._targetEnd).add(A.multiplyScalar(this._dollyControlCoord.x*P*D.aspect)).add(y.multiplyScalar(this._dollyControlCoord.y*P)),m=f.copy(this._targetEnd).lerp(c,l),T=this._lastDollyDirection===k.IN&&this._spherical.radius<=this.minDistance,g=this._lastDollyDirection===k.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(T||g)){this._sphericalEnd.radius-=E,this._spherical.radius-=E;const R=C.copy(u).multiplyScalar(-E);m.add(R)}this._boundary.clampPoint(m,m);const U=C.subVectors(m,this._targetEnd);this._targetEnd.copy(m),this._target.add(U),this._changedDolly-=E,v(this._changedDolly)&&(this._changedDolly=0)}else if(N(this._camera)&&this._changedZoom!==0){const E=this._zoom-this._lastZoom,D=this._camera,u=f.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(D.near+D.far)/(D.near-D.far)).unproject(D),A=C.set(0,0,-1).applyQuaternion(D.quaternion),y=V.copy(u).add(A.multiplyScalar(-u.dot(D.up))),o=-(this._zoom-E-this._zoom)/this._zoom,l=this._getCameraDirection(q),c=this._targetEnd.dot(l),m=f.copy(this._targetEnd).lerp(y,o),T=m.dot(l),g=l.multiplyScalar(T-c);m.sub(g),this._boundary.clampPoint(m,m);const U=C.subVectors(m,this._targetEnd);this._targetEnd.copy(m),this._target.add(U),this._changedZoom-=E,v(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const _=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,_),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!v(this._focalOffset.x)||!v(this._focalOffset.y)||!v(this._focalOffset.z))&&(M.setFromMatrixColumn(this._camera.matrix,0),H.setFromMatrixColumn(this._camera.matrix,1),Y.setFromMatrixColumn(this._camera.matrix,2),M.multiplyScalar(this._focalOffset.x),H.multiplyScalar(-this._focalOffset.y),Y.multiplyScalar(this._focalOffset.z),f.copy(M).add(H).add(Y),this._camera.position.add(f),this._camera.updateMatrixWorld()),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),f.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const x=this._needsUpdate;return x&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):x?(this.dispatchEvent({type:"update"}),v(e,this.restThreshold)&&v(i,this.restThreshold)&&v(r,this.restThreshold)&&v(n.x,this.restThreshold)&&v(n.y,this.restThreshold)&&v(n.z,this.restThreshold)&&v(a.x,this.restThreshold)&&v(a.y,this.restThreshold)&&v(a.z,this.restThreshold)&&v(h,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!x&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=x,this._needsUpdate=!1,x}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:X(this.maxDistance),minZoom:this.minZoom,maxZoom:X(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:X(this.maxPolarAngle),minAzimuthAngle:X(this.minAzimuthAngle),maxAzimuthAngle:X(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,target:this._targetEnd.toArray(),position:f.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(t,e=!1){const i=JSON.parse(t);this.enabled=i.enabled,this.minDistance=i.minDistance,this.maxDistance=Q(i.maxDistance),this.minZoom=i.minZoom,this.maxZoom=Q(i.maxZoom),this.minPolarAngle=i.minPolarAngle,this.maxPolarAngle=Q(i.maxPolarAngle),this.minAzimuthAngle=Q(i.minAzimuthAngle),this.maxAzimuthAngle=Q(i.maxAzimuthAngle),this.smoothTime=i.smoothTime,this.draggingSmoothTime=i.draggingSmoothTime,this.dollySpeed=i.dollySpeed,this.truckSpeed=i.truckSpeed,this.dollyToCursor=i.dollyToCursor,this._target0.fromArray(i.target0),this._position0.fromArray(i.position0),this._zoom0=i.zoom0,this._focalOffset0.fromArray(i.focalOffset0),this.moveTo(i.target[0],i.target[1],i.target[2],e),w.setFromVector3(f.fromArray(i.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(w.theta,w.phi,e),this.dollyTo(w.radius,e),this.zoomTo(i.zoom,e),this.setFocalOffset(i.focalOffset[0],i.focalOffset[1],i.focalOffset[2],e),this._needsUpdate=!0}connect(t){if(this._domElement){console.warn("camera-controls is already connected.");return}t.setAttribute("data-camera-controls-version",Dt),this._addAllEventListeners(t),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(t){return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(t){return this._getTargetDirection(t).negate()}_findPointerById(t){return this._activePointers.find(e=>e.pointerId===t)}_findPointerByMouseButton(t){return this._activePointers.find(e=>e.mouseButton===t)}_disposePointer(t){this._activePointers.splice(this._activePointers.indexOf(t),1)}_encloseToBoundary(t,e,i){const r=e.lengthSq();if(r===0)return t;const n=C.copy(e).add(t),h=this._boundary.clampPoint(n,V).sub(n),_=h.lengthSq();if(_===0)return t.add(e);if(_===r)return t;if(i===0)return t.add(e).add(h);{const p=1+i*_/e.dot(h);return t.add(C.copy(e).multiplyScalar(p)).add(h.multiplyScalar(1-i))}}_updateNearPlaneCorners(){if(I(this._camera)){const t=this._camera,e=t.near,i=t.getEffectiveFOV()*K,r=Math.tan(i*.5)*e,n=r*t.aspect;this._nearPlaneCorners[0].set(-n,-r,0),this._nearPlaneCorners[1].set(n,-r,0),this._nearPlaneCorners[2].set(n,r,0),this._nearPlaneCorners[3].set(-n,r,0)}else if(N(this._camera)){const t=this._camera,e=1/t.zoom,i=t.left*e,r=t.right*e,n=t.top*e,a=t.bottom*e;this._nearPlaneCorners[0].set(i,n,0),this._nearPlaneCorners[1].set(r,n,0),this._nearPlaneCorners[2].set(r,a,0),this._nearPlaneCorners[3].set(i,a,0)}}_collisionTest(){let t=1/0;if(!(this.colliderMeshes.length>=1)||it(this._camera,"_collisionTest"))return t;const i=this._getTargetDirection(q);ht.lookAt(mt,i,this._camera.up);for(let r=0;r<4;r++){const n=C.copy(this._nearPlaneCorners[r]);n.applyMatrix4(ht);const a=V.addVectors(this._target,n);tt.set(a,i),tt.far=this._spherical.radius+1;const h=tt.intersectObjects(this.colliderMeshes);h.length!==0&&h[0].distance<t&&(t=h[0].distance)}return t}_getClientRect(t){if(!this._domElement)return;const e=this._domElement.getBoundingClientRect();return t.x=e.left,t.y=e.top,this._viewport?(t.x+=this._viewport.x,t.y+=e.height-this._viewport.w-this._viewport.y,t.width=this._viewport.z,t.height=this._viewport.w):(t.width=e.width,t.height=e.height),t}_createOnRestPromise(t){return t?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(e=>{const i=()=>{this.removeEventListener("rest",i),e()};this.addEventListener("rest",i)}))}_addAllEventListeners(t){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(t){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(t){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(t,e=new d.Sphere){const i=e,r=i.center;B.makeEmpty(),t.traverseVisible(a=>{a.isMesh&&B.expandByObject(a)}),B.getCenter(r);let n=0;return t.traverseVisible(a=>{if(!a.isMesh)return;const h=a;if(!h.geometry)return;const _=h.geometry.clone();_.applyMatrix4(h.matrixWorld);const x=_.attributes.position;for(let E=0,D=x.count;E<D;E++)f.fromBufferAttribute(x,E),n=Math.max(n,r.distanceToSquared(f))}),i.radius=Math.sqrt(n),i}}export{lt as C};
